{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome my Klipper Misc Docs","text":"<p>In this Documentation, you will find a comprehensive guide on setting up CAN devices with Klipper. Klipper is a powerful open-source firmware that allows you to optimize and expand your 3D printer setups.</p> <p>In this documentation, we (DocGalaxyBlock and me) will explain in detail how to integrate CAN devices into your Klipper configuration. CAN (Controller Area Network) is a serial communication standard used in various industrial and automotive applications. By using CAN, you can establish reliable and efficient communication between your host and control components, enhancing your printing results.</p> <p>Additionally, this repository provides further specific instructions and information on Klipper. We cover exclusive guides to use Klipper specific functions. Our goal is to provide you with a comprehensive resource that enables you to unleash the full potential of Klipper.</p> <p>We are committed to regularly updating this documentation and adding new content to ensure you have the latest information. We warmly invite you to actively participate in the community, ask questions, and provide suggestions for improvement. Together, we can contribute to making Klipper and the use of CAN devices even better.</p> <p>Furthermore, we encourage you to utilize the Issue Tracker and PR (Pull Request) section of this repository to suggest improvements or report any issues you encounter while using Klipper with CAN devices. Your feedback and contributions are highly valued, and they play a vital role in enhancing the overall Klipper experience for the community. Together, let's make Klipper and CAN integration even more robust and user-friendly.</p> <p>Please feel free to open new issues or submit pull requests with your ideas, bug reports, or code contributions. We appreciate your active participation and look forward to collaborating with you to make Klipper and the CAN documentation as comprehensive and helpful as possible.</p> <p>Thank you for choosing this documentation. We hope it assists you in setting up and utilizing your Klipper-based controllers.</p> <p>Let's get started!</p>"},{"location":"btt-ebb/","title":"BigTreeTech EBB","text":"<p>This is an instruction to set up the BTT EBB36, EBB42 and EBB SB2209/2240 with Klipper via CANBUS.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.1</li> <li>BTT EBB36 &amp; 42 v1.2</li> <li>BTT EBB SB2209/2240 v1.0</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p> <p>This guide will not work with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.0</li> </ul> <p>These boards have a different MCU.</p>"},{"location":"btt-ebb/#ebb36-42-v11-v12","title":"EBB36 &amp; 42 v1.1 &amp; v1.2","text":"<ul> <li>official Repository for the EBB36 v1.1 &amp; v1.2<ul> <li>Schematic</li> <li>Size</li> <li>User Manual</li> </ul> </li> <li>official Repository for the EBB42 v1.1 &amp; v1.2<ul> <li>Schematic</li> <li>Size</li> <li>User Manual</li> </ul> </li> <li>Sample config v1.1</li> <li>Sample config v1.2</li> </ul>"},{"location":"btt-ebb/#hardware","title":"Hardware","text":"<ul> <li>MCU: ARM Cortex-M0+ STM32G0B1CBT6 64MHz whit FDCAN bus</li> <li>Stepper Dirver: Onboard TMC2209 in UART mode, UART address: 00, Rsense: 0.11R</li> <li>Onboard Accelerometer Sensor: ADXL345</li> <li>Onboard Temperature IC: Max31865 Select 2 / 4 lines PT100 / PT1000 by DIP switch (no Max31865 verson have not this feature)</li> <li>Input Voltage: DC12V-DC24V 6A</li> <li>Logic Voltage: DC 3.3V</li> <li>Heating Interface: Hotend (E0), maximum output current: 5A</li> <li>Fan Interfaces: two CNC fans (FAN0, FAN1)</li> <li>Maximum Output Current of Fan Interface: 1A, Peak Value 1.5A</li> <li>Expansion Interfaces: EndStop, I2C, Probe, RGB, PT100/PT1000, USB interface, CAN Interface</li> <li>Temperature Sensor Interface Optional: 1 Channel 100K NTC or PT1000(TH0), 1 Channel PT100/PT1000</li> <li>USB Communication Interface: USB-Type-C</li> <li>DC 5V Maximum Output Current: 1A</li> </ul>"},{"location":"btt-ebb/#pinout-ebb36-v11-v12","title":"Pinout EBB36 v1.1 &amp; v1.2","text":""},{"location":"btt-ebb/#pinout-ebb42-v11-v12","title":"Pinout EBB42 v1.1 &amp; v1.2","text":""},{"location":"btt-ebb/#ebb-sb22092240-v10","title":"EBB SB2209/2240 v1.0","text":"<ul> <li>official Repository for the EBB SB2209/2240 v1.0</li> <li>Sample config</li> <li>Schematic EBB SB2209</li> <li>Size EBB SB2209 Mainboard</li> <li>Size EBB SB2209 Subboard</li> <li>Schematic EBB SB2240</li> <li>Size EBB SB2240 Mainboard</li> <li>Size EBB SB2240 Subboard</li> <li>User Manual</li> </ul>"},{"location":"btt-ebb/#hardware_1","title":"Hardware","text":"<ul> <li>MCU: ARM Cortex-M0+ STM32G0B1CBT6 64MHz whit FDCAN bus</li> <li> <p>Stepper Dirver:</p> <ul> <li>TMC2209 Version: Onboard TMC2209 in UART mode, UART address: 00, Rsense: 0.11R</li> <li>TMC2240 Version: Onboard TMC2240 in SPI mode</li> </ul> </li> <li> <p>Onboard Accelerometer Sensor: ADXL345</p> </li> <li>Onboard Temperature IC: Max31865 Select 2 / 4 lines PT100 / PT1000 by DIP switch</li> <li>Input Voltage: DC12V-DC24V 9A</li> <li>Logic Voltage: DC 3.3V</li> <li>Heating Interface: Hotend (E0), maximum output current: 5A</li> <li> <p>Fan Interfaces:</p> <ul> <li>2 x CNC fans (FAN1, FAN2)</li> <li>1 x 4-wire fan (4W_FAN)</li> </ul> </li> <li> <p>Maximum Output Current of Fan Interface: 1A, Peak Value 1.5A</p> </li> <li>Expansion Interfaces: EndStop, Bltouch, Proximity(NPN &amp; PNP), RGB, PT100/PT1000, USB, CAN, SPI</li> <li>Temperature Sensor Interface Optional: 1 Channel 100K NTC or PT1000(TH0), 1 Channel PT100/PT1000 (Max31865)</li> <li>USB Communication Interface: USB-Type-C</li> <li>DC 5V Maximum Output Current: 1A</li> </ul>"},{"location":"btt-ebb/#pinout-ebb-sb2209-v10","title":"Pinout EBB SB2209 v1.0","text":""},{"location":"btt-ebb/#pinout-ebb-sb2240-v10","title":"Pinout EBB SB2240 v1.0","text":""},{"location":"btt-ebb/canboot/","title":"CanBoot bootloader (optional)","text":"<p>Canboot is a bootloader for MCUs to be able to update/flash them via CANBUS. With CanBoot there is no physical intervention (e.g. pressing the boot button) required to flash/update firmware to the MCUs.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.1</li> <li>BTT EBB36 &amp; 42 v1.2</li> <li>BTT EBB SB2209/2240 v1.0</li> </ul> <p>This guide will not work with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.0</li> </ul> <p>These boards have a different MCU.</p>"},{"location":"btt-ebb/canboot/#download-canboot","title":"Download CanBoot","text":"<p>Clone the CanBoot repository: <pre><code>cd ~\ngit clone https://github.com/Arksine/CanBoot\n</code></pre> To add CanBoot to your moonraker update manager, add this section to your config (optional): moonraker.conf<pre><code>[update_manager canboot]\ntype: git_repo\norigin: https://github.com/Arksine/CanBoot.git\npath: ~/CanBoot\nis_system_service: False\n</code></pre></p>"},{"location":"btt-ebb/canboot/#configure-canboot","title":"Configure CanBoot","text":"<p>Open the config dialog with the following commands: <pre><code>cd ~/CanBoot\nmake menuconfig\n</code></pre> and use following config settings:</p> <ul> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32G0B1</li> <li>Build CanBoot deployment application: 8KiB bootloader</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: CAN bus (on PB0/PB1)</li> <li>Application start offset: 8KiB offset</li> <li>CAN bus speed: 500000</li> <li>Support bootloader entry on rapid double click of reset button: check (optional but recommend)</li> <li>Enable Status LED: check</li> <li>Status LED GPIO Pin: PA13</li> </ul> <p>this should then look like this:</p> <p> </p> CanBoot config for EBB devices <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>These lines just clear the cache and compile the CanBoot bootloader: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"btt-ebb/canboot/#flash-canboot","title":"Flash CanBoot","text":"Before you start the flashing process, disconnect the heater from the board! <p>Up to version v1.1, the heater output is switched to on in DFU mode while in this mode! This can lead to a fire! \ud83d\udd25 Like in the next picture where the door bell ringed \ud83d\udd14 In version v1.2, this pin has changed because of this issue.</p> <p> (only the printer was harmed - picture used with permission) </p> <p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply, or press the reset button on the board. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash CanBoot with the following command: <pre><code>dfu-util -a 0 -D ~/CanBoot/out/canboot.bin -s 0x08000000:mass-erase:force:leave\n</code></pre>  Now press the reset button and if the flash process was successfully one LED should blink now.</p>"},{"location":"btt-ebb/canboot/#update-canboot","title":"Update CanBoot","text":"<p>If you want to update CanBoot, you have multiple possible ways to do this.</p>"},{"location":"btt-ebb/canboot/#update-canboot-via-usb","title":"Update CanBoot via USB","text":"<p>If you want to update CanBoot via USB, you have to plug in a USB cable and continue with the \"old\" guide here: Flash CanBoot to the EBB</p>"},{"location":"btt-ebb/canboot/#update-canboot-via-can","title":"Update CanBoot via CAN","text":"<p>Since the board can only be addressed via CAN, further CanBoot updates must also be flashed to the board via CAN. This is very easy with the CanBoot bootloader: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/CanBoot/out/canboot.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"btt-ebb/klipper/","title":"Klipper Firmware for BigTreeTech EBB","text":"<p>The BigTreeTech EBB series is a toolhead board series that can communicate via CAN. This guide explains which settings you need, to flash your EBB boards with Klipper.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.1</li> <li>BTT EBB36 &amp; 42 v1.2</li> <li>BTT EBB SB2209/2240 v1.0</li> </ul> <p>This guide will not work with the following boards:</p> <ul> <li>BTT EBB36 &amp; 42 v1.0</li> </ul> <p>These boards have a different MCU.</p> <p>Info</p> <p>Use at least a Klipper version of v0.10.0-531 to use the board safely! In this commit, Kevin fixed a bug in the ADC calculation of the STM32G0.</p>"},{"location":"btt-ebb/klipper/#configure-klipper-firmware","title":"Configure Klipper firmware","text":"<p>Open the config interface of the Klipper firmware with following commands: <pre><code>cd ~/klipper\nmake menuconfig\n</code></pre> and set the following settings:</p> <ul> <li>Enable extra low-level configuration options: check</li> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32G0B1</li> <li>Bootloader offset: No bootloader (without CanBoot)</li> <li>Bootloader offset: 8KiB bootloader (with CanBoot)</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: CAN bus (on PB0/PB1)</li> <li>CAN bus speed: 500000</li> </ul> <p>The result should look like this:</p> <p> </p> Klipper config for EBB devices <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"btt-ebb/klipper/#flash-klipper","title":"Flash Klipper","text":"<p>There are two ways to flash the Klipper firmware to the EBB.</p> <ul> <li>Flash the firmware via USB </li> <li>Flash the firmware via CAN (recommended) (only with CanBoot)</li> </ul>"},{"location":"btt-ebb/klipper/#flash-klipper-via-usb","title":"Flash Klipper via USB","text":"<p>This is the classic way to flash the firmware to the EBB.</p> Before you start the flashing process, disconnect the heater from the board! <p>Up to version v1.1, the heater output is switched to on in DFU mode while in this mode! This can lead to a fire! \ud83d\udd25 Like in the next picture where the door bell ringed \ud83d\udd14 In version v1.2, this pin has changed because of this issue.</p> <p> (only the printer was harmed - picture used with permission) </p> <p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply, or press the reset button on the board. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>It should then look like this: </p> <p>If your board is in DFU mode, you can flash Klipper with the following command: <pre><code>dfu-util -a 0 -D ~/klipper/out/klipper.bin -s 0x08000000:mass-erase:force:leave\n</code></pre> </p>"},{"location":"btt-ebb/klipper/#flash-klipper-via-can","title":"Flash Klipper via CAN","text":"<p>This is the recommended way to flash the firmware, when you use CanBoot on your board.</p> <p>Find the UUID of your board: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -i can0 -q\n</code></pre> The output should look like this: </p> <p>With the UUID you have just read, you can now flash the board with: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/klipper/out/klipper.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"btt-ebb/klipper/#add-the-mcu-in-klipper","title":"Add the MCU in Klipper","text":"<p>Finally, you can add the board to your Klipper <code>printer.cfg</code> with its UUID: printer.cfg<pre><code>[mcu EBB]\ncanbus_uuid: &lt;uuid&gt;\n\n# embedded temperature sensor\n[temperature_sensor EBB]\nsensor_type: temperature_mcu\nsensor_mcu: EBB\nmin_temp: 0\nmax_temp: 100\n</code></pre></p> <p>If you don't know the UUID of your EBB, you can read it out with the following command: <pre><code>~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n</code></pre> The output should look like this: </p>"},{"location":"btt-pi-u2c/","title":"BigTreeTech PI v1.2 + U2C Module v1.0","text":"<p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech Pi v1.2</li> <li>U2C Module v1.0</li> </ul> <p>This guide was verified on a BigTreeTech Pi v1.2 running CB1 Debian11 Klipper</p> <p>This is an instruction to set up a BigTreeTech Pi v1.2 with a U2C Module v1.0 with Klipper. The BigTreeTech Pi v1.2 is a Raspberry Pi alternative with a H616 SoC. The U2C Module v1.0 is a USB-to-CAN adapter, which can be plugged on the top of the BigTreeTech Pi v1.2 as a HAT.</p> <p></p> <p>This module is already preconfigured &amp; flashed by BigTreeTech. Turn off the Pi, remove the power supply, and plug the module on the Pi. After the Pi is fully booted again, CAN should be ready.</p>"},{"location":"btt-pi-u2c/#using-u2c-module-v10-on-the-minimal-cb1-image","title":"Using U2C Module v1.0 on the minimal CB1 image","text":"<p>this is only needed if...</p> <p>you use the minimal image from BigTreeTech. The minimal Image have nothing preinstalled from the the Klipper enviroment.</p> <ul> <li>BigTreeTech Pi v1.2</li> <li>U2C Module v1.0</li> </ul> <p>This guide was verified on a BigTreeTech Pi v1.2 running CB1 Debian11 minimal</p> <p>On the minimal image the CAN interface must be configured first. This can be done with the <code>/etc/network/interfaces.d/can0</code> file. Follow the steps below to set them up.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"btt-u2c-v1.x/","title":"BigTreeTech U2C v1.x","text":"<p>This is an instruction to set up the BTT U2C with Klipper. There are two possible variants. Use the board as a pure CANBUS adapter (candlelight FW) or a Klipper USB-to-CAN adapter.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v1.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p> <p>There are multiple solutions to run the U2C with Klipper:</p> <ul> <li>CandleLight_FW (recommended)</li> <li>Klipper USB-to-CAN adapter</li> </ul> <p>The straightforward variant to use the U2C is the candlelight firmware. With this, very little has to be configured, and you don't have to update it with Klipper MCU updates. With the U2C, there are few advantages through the Klipper firmware since no freely assignable pins are available on the board.</p>"},{"location":"btt-u2c-v1.x/#links","title":"Links","text":"<ul> <li>official Repository for the U2C v1.x<ul> <li>Schematic v1.0</li> <li>Schematic v1.1</li> <li>User Manual</li> </ul> </li> </ul>"},{"location":"btt-u2c-v1.x/#pinout","title":"Pinout","text":""},{"location":"btt-u2c-v1.x/canboot/","title":"CanBoot bootloader (optional)","text":"<p>Canboot is a bootloader for MCUs to be able to update/flash them via CANBUS. With CanBoot there is no physical intervention (e.g. pressing the boot button) required to flash/update firmware to the MCUs.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v1.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"btt-u2c-v1.x/canboot/#download-canboot","title":"Download CanBoot","text":"<p>Clone the CanBoot repository: <pre><code>cd ~\ngit clone https://github.com/Arksine/CanBoot\n</code></pre> To add CanBoot to your moonraker update manager, add this section to your config (optional): moonraker.conf<pre><code>[update_manager canboot]\ntype: git_repo\norigin: https://github.com/Arksine/CanBoot.git\npath: ~/CanBoot\nis_system_service: False\n</code></pre></p>"},{"location":"btt-u2c-v1.x/canboot/#configure-canboot","title":"Configure CanBoot","text":"<p>Open the config dialog with the following commands: <pre><code>cd ~/CanBoot\nmake menuconfig\n</code></pre> and use following config settings:</p> <ul> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32F072</li> <li>Build CanBoot deployment application: 8KiB bootloader</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: USB (on PA11/PA12)</li> <li>Application start offset: 8KiB offset</li> <li>Support bootloader entry on rapid double click of reset button: check</li> <li>Enable Status LED: check</li> <li>Status LED GPIO Pin: PA14</li> </ul> <p>this should then look like this:</p> <p> </p> CanBoot config for U2C v1.x <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>These lines just clear the cache and compile the CanBoot bootloader: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"btt-u2c-v1.x/canboot/#flash-canboot","title":"Flash CanBoot","text":"<p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash CanBoot with the following command: <pre><code>dfu-util -a 0 -D ~/CanBoot/out/canboot.bin -s 0x08000000:mass-erase:force:leave\n</code></pre>  Now press the reset button and if the flash process was successfully one LED should blink now.</p>"},{"location":"btt-u2c-v1.x/canboot/#update-canboot","title":"Update CanBoot","text":"<p>If you want to update CanBoot, you have multiple possible ways to do this.</p>"},{"location":"btt-u2c-v1.x/canboot/#update-canboot-via-usb","title":"Update CanBoot via USB","text":"<p>If you want to update CanBoot via USB, you have to plug in a USB cable and continue with the \"old\" guide here: Flash CanBoot via USB</p>"},{"location":"btt-u2c-v1.x/canboot/#update-canboot-via-can","title":"Update CanBoot via CAN","text":"<p>Since the board can only be addressed via CAN, further CanBoot updates must also be flashed to the board via CAN. This is very easy with the CanBoot bootloader: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/CanBoot/out/canboot.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"btt-u2c-v1.x/candlelight/","title":"CandleLight_FW (U2C v1.x)","text":"<p>CandleLight_FW is a firmware for STM32F042x/STM32F072xB based USB-CAN adapters.</p> <p>Github: github.com/candle-usb/candleLight_fw</p>"},{"location":"btt-u2c-v1.x/candlelight/#compile-candlelight_fw","title":"Compile CandleLight_FW","text":"<pre><code># install requirements\nsudo apt-get install cmake gcc-arm-none-eabi\n\ncd ~\n# clone git repo\ngit clone --depth=1 https://github.com/candle-usb/candleLight_fw\ncd ~/candleLight_fw\n\n# create cmake toolchain\nmkdir build\ncd build\ncmake .. -DCMAKE_TOOLCHAIN_FILE=../cmake/gcc-arm-none-eabi-8-2019-q3-update.cmake\n\n# compile firmware\nmake candleLight_fw\n</code></pre>"},{"location":"btt-u2c-v1.x/candlelight/#flash-candlelight_fw","title":"Flash CandleLight_FW","text":"<p>First, the adapter must boot in DFU mode. Please press the boot button and then connect the USB cable. With <code>dfu-util -l</code>, you can check whether the adapter is booted in DFU mode. This should look like this:</p> <p>If dfu-util can discover a board in DFU mode it should then look like this: </p> <p>If the BTT U2C has booted in DFU mode, you can flash it with this command:</p> <pre><code>make flash-candleLight_fw\n</code></pre> <p>It should then look like this: </p>"},{"location":"btt-u2c-v1.x/candlelight/#add-can0-interface","title":"Add can0 interface","text":"<p>Now you only have to create the interface in the OS. to do this, create the file <code>/etc/network/interfaces.d/can0</code> and fill it with the following content.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"btt-u2c-v1.x/klipper-usb-to-can/","title":"Klipper USB-to-CAN bus bridge","text":"<p>Klipper has also the posibillity to use the U2C as a USB-to-CAN bus bridge. This is a good solution if you want to use the board as a CANBUS adapter for your printer and an MCU at the same time. In the case of the BigTreeTech U2C, this solution has no advantages over the candlelight firmware, since no freely usable pins are available on the board.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v1.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"btt-u2c-v1.x/klipper-usb-to-can/#configure-klipper-firmware","title":"Configure Klipper firmware","text":"<p>Open the config interface of the Klipper firmware with following commands: <pre><code>cd ~/klipper\nmake menuconfig\n</code></pre> and set the following settings:</p> <ul> <li>Enable extra low-level configuration options: check</li> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32F072</li> <li>Bootloader offset: No bootloader (without CanBoot)</li> <li>Bootloader offset: 8KiB bootloader (with CanBoot)</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: USB to CAN bus bridge (USB on PA11/PA12)</li> <li>CAN bus interface: CAN bus (on PB8/PB9)</li> <li>CAN bus speed: 500000</li> </ul> <p>The result should look like this:</p> <p> </p> Klipper config for U2C v1.x in bridge mode <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"btt-u2c-v1.x/klipper-usb-to-can/#flash-klipper","title":"Flash Klipper","text":"<p>There are two ways to flash the Klipper firmware to the board.</p> <ul> <li>Flash the firmware via USB (without CanBoot)</li> <li>Flash the firmware via CAN (with CanBoot)</li> </ul>"},{"location":"btt-u2c-v1.x/klipper-usb-to-can/#flash-klipper-via-usb","title":"Flash Klipper via USB","text":"<p>This is the classic way to flash the firmware to the board.</p> <p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>It should then look like this: </p> <p>If your board is in DFU mode, you can flash Klipper with the following command: <pre><code>dfu-util -a 0 -D ~/klipper/out/klipper.bin -s 0x08000000:mass-erase:force:leave\n</code></pre> </p>"},{"location":"btt-u2c-v1.x/klipper-usb-to-can/#flash-klipper-via-can","title":"Flash Klipper via CAN","text":"<p>This is the recommended way to flash the firmware, when you use CanBoot on your board.</p> <p>The U2C must be in the bootloader mode</p> <p>The status LED should blink in the bootloader mode. If not, double press the reset button to enter the bootloader mode.</p> <p>Find the UUID of your U2C: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -i can0 -q\n</code></pre> The output should look like this: </p> <p>With the UUID you have just read, you can now flash the board with: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/klipper/out/klipper.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"btt-u2c-v1.x/klipper-usb-to-can/#add-can0-interface","title":"Add can0 interface","text":"<p>Now you only have to create the interface in the OS. to do this, create the file <code>/etc/network/interfaces.d/can0</code> and fill it with the following content.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"btt-u2c-v1.x/klipper-usb-to-can/#add-the-mcu-in-klipper-optional","title":"Add the MCU in Klipper (optional)","text":"<p>Finally, you can add the board to your Klipper <code>printer.cfg</code> with its UUID: printer.cfg<pre><code>[mcu U2C]\ncanbus_uuid: &lt;uuid&gt;\n\n# embedded temperature sensor\n[temperature_sensor U2C]\nsensor_type: temperature_mcu\nsensor_mcu: U2C\nmin_temp: 0\nmax_temp: 100\n</code></pre></p> <p>If you don't know the UUID of your U2C, you can read it out with the following command: <pre><code>~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n</code></pre> The output should look like this: </p>"},{"location":"btt-u2c-v2.x/","title":"BigTreeTech U2C v2.x","text":"<p>This is an instruction to set up the BTT U2C with Klipper. There are two possible variants. Use the board as a pure CANBUS adapter (candlelight FW) or a Klipper USB-to-CAN adapter.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v2.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p> <p>There are multiple solutions to run the U2C with Klipper:</p> <ul> <li>CandleLight_FW (BTT fork) (recommended)</li> <li>Klipper USB-to-CAN</li> </ul> <p>The straightforward variant to use the U2C is the candlelight firmware. With this, very little has to be configured, and you don't have to update it with Klipper MCU updates. With the U2C, there are few advantages through the Klipper firmware since no freely assignable pins are available on the board.</p>"},{"location":"btt-u2c-v2.x/#links","title":"Links","text":"<ul> <li>official Repository for the U2C<ul> <li>Schematic v1.1   (this is the schematic for v1.1, but it is also valid for v2.x)</li> <li>User Manual   (this is the guide for v1.x, but it is also valid for v2.x)</li> </ul> </li> </ul>"},{"location":"btt-u2c-v2.x/#pinout","title":"Pinout","text":""},{"location":"btt-u2c-v2.x/canboot/","title":"CanBoot bootloader (optional)","text":"<p>Canboot is a bootloader for MCUs to be able to update/flash them via CANBUS. With CanBoot there is no physical intervention (e.g. pressing the boot button) required to flash/update firmware to the MCUs.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v2.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"btt-u2c-v2.x/canboot/#download-canboot","title":"Download CanBoot","text":"<p>Clone the CanBoot repository: <pre><code>cd ~\ngit clone https://github.com/Arksine/CanBoot\n</code></pre> To add CanBoot to your moonraker update manager, add this section to your config (optional): moonraker.conf<pre><code>[update_manager canboot]\ntype: git_repo\norigin: https://github.com/Arksine/CanBoot.git\npath: ~/CanBoot\nis_system_service: False\n</code></pre></p>"},{"location":"btt-u2c-v2.x/canboot/#configure-canboot","title":"Configure CanBoot","text":"<p>Open the config dialog with the following commands: <pre><code>cd ~/CanBoot\nmake menuconfig\n</code></pre> and use following config settings:</p> <ul> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32G0B1</li> <li>Build CanBoot deployment application: 8KiB bootloader</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: USB (on PA11/PA12)</li> <li>Application start offset: 8KiB offset</li> <li>Support bootloader entry on rapid double click of reset button: check</li> <li>Enable Status LED: check</li> <li>Status LED GPIO Pin: PA13</li> </ul> <p>this should then look like this:</p> <p> </p> CanBoot config for U2C v2.x <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>These lines just clear the cache and compile the CanBoot bootloader: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"btt-u2c-v2.x/canboot/#flash-canboot","title":"Flash CanBoot","text":"<p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash CanBoot with the following command: <pre><code>dfu-util -a 0 -D ~/CanBoot/out/canboot.bin -s 0x08000000:mass-erase:force:leave\n</code></pre>  Now power cycle the board if the flash process was successfully one LED should blink now.</p>"},{"location":"btt-u2c-v2.x/candlelight/","title":"CandleLight_FW (U2C v1.x)","text":"<p>But the U2C v2.x has the STM32G0B1 that currently is not supported by the official CandleLight project. Therefore, BigTreeTech created a fork of that project and added STM32G0B1 support.</p> <p>Github: github.com/bigtreetech/candleLight_fw/tree/stm32g0_support</p>"},{"location":"btt-u2c-v2.x/candlelight/#compile-candlelight_fw-budgetcan_fw","title":"Compile CandleLight_FW (budgetcan_fw)","text":"<pre><code># install requirements\nsudo apt-get install cmake gcc-arm-none-eabi\n\ncd ~\n# clone git repo\ngit clone --depth=1 -b stm32g0_support https://github.com/bigtreetech/candleLight_fw\ncd ~/candleLight_fw\n\n# create cmake toolchain\nmkdir build\ncd build\ncmake .. -DCMAKE_TOOLCHAIN_FILE=../cmake/gcc-arm-none-eabi-8-2019-q3-update.cmake\n\n# compile firmware\nmake budgetcan_fw\n</code></pre>"},{"location":"btt-u2c-v2.x/candlelight/#flash-candlelight_fw-budgetcan_fw","title":"Flash CandleLight_FW (budgetcan_fw)","text":"<p>First, the adapter must boot in DFU mode. Please press the boot button and then connect the USB cable. With <code>dfu-util -l</code>, you can check whether the adapter is booted in DFU mode. This should look like this:</p> <p>If dfu-util can discover a board in DFU mode it should then look like this: </p> <p>If the BTT U2C has booted in DFU mode, you can flash it with this command:</p> <pre><code>make flash-budgetcan_fw\n</code></pre> <p>It should then look like this: </p>"},{"location":"btt-u2c-v2.x/candlelight/#add-can0-interface","title":"Add can0 interface","text":"<p>Now you only have to create the interface in the OS. to do this, create the file <code>/etc/network/interfaces.d/can0</code> and fill it with the following content.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"btt-u2c-v2.x/klipper-usb-to-can/","title":"Klipper USB-to-CAN bus bridge","text":"<p>Klipper has also the posibillity to use the U2C as a USB-to-CAN bus bridge. This is a good solution if you want to use the board as a CANBUS adapter for your printer and an MCU at the same time. In the case of the BigTreeTech U2C, this solution has no advantages over the candlelight firmware, since no freely usable pins are available on the board.</p> <p>This guide is tested with the following boards:</p> <ul> <li>BigTreeTech U2C v2.1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"btt-u2c-v2.x/klipper-usb-to-can/#configure-klipper-firmware","title":"Configure Klipper firmware","text":"<p>Open the config interface of the Klipper firmware with following commands: <pre><code>cd ~/klipper\nmake menuconfig\n</code></pre> and set the following settings:</p> <ul> <li>Enable extra low-level configuration options: check</li> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32G0B1</li> <li>Bootloader offset: No bootloader (without CanBoot)</li> <li>Bootloader offset: 8KiB bootloader (with CanBoot)</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: USB to CAN bus bridge (USB on PA11/PA12)</li> <li>CAN bus interface: CAN bus (on PB5/PB6)</li> <li>CAN bus speed: 500000</li> </ul> <p>The result should look like this:</p> <p> </p> Klipper config for U2C v2.x in bridge mode <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"btt-u2c-v2.x/klipper-usb-to-can/#flash-klipper","title":"Flash Klipper","text":"<p>There are two ways to flash the Klipper firmware to the board.</p> <ul> <li>Flash the firmware via USB (without CanBoot)</li> <li>Flash the firmware via USB (with CanBoot)</li> </ul>"},{"location":"btt-u2c-v2.x/klipper-usb-to-can/#flash-klipper-via-usb-without-canboot","title":"Flash Klipper via USB without CanBoot","text":"<p>This is the classic way to flash the firmware to the board.</p> <p>First, you have to put the board into DFU mode. To do this, press and hold the boot button and then disconnect and reconnect the power supply. With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode.</p> <p>It should then look like this: </p> <p>If your board is in DFU mode, you can flash Klipper with the following command: <pre><code>dfu-util -a 0 -D ~/klipper/out/klipper.bin -s 0x08000000:mass-erase:force:leave\n</code></pre> </p>"},{"location":"btt-u2c-v2.x/klipper-usb-to-can/#flash-klipper-via-usb-with-canboot","title":"Flash Klipper via USB with CanBoot","text":"<p>This method is necessary if you don't have Klipper on your board, but flashed the CanBoot firmware already.</p> <p>At first, you have to get the serial ID for your board. To do this, you have to exectute the following command: <pre><code># find your &lt;serial device&gt; full path\nls /dev/serial/by-id/*\n</code></pre></p> <p>Then you have to use this path in the following command: <pre><code># flash Klipper\npython3 ~/CanBoot/scripts/flash_can.py -f ~/klipper/out/klipper.bin -d &lt;serial device&gt;\n</code></pre> This should look like this: </p> <p>Power cycle the board and you are done.</p>"},{"location":"btt-u2c-v2.x/klipper-usb-to-can/#add-can0-interface","title":"Add can0 interface","text":"<p>Now you only have to create the interface in the OS. to do this, create the file <code>/etc/network/interfaces.d/can0</code> and fill it with the following content.</p> <pre><code># open file with nano\nsudo nano /etc/network/interfaces.d/can0\n</code></pre> /etc/network/interfaces.d/can0<pre><code>allow-hotplug can0\niface can0 can static\n    bitrate 500000\n    up ifconfig $IFACE txqueuelen 128\n</code></pre> <p>To save and close the nano editor: <code>ctrl+s</code> =&gt; save file <code>ctrl+x</code> =&gt; close editor</p> <p>After a reboot, the can interface should be ready.</p>"},{"location":"btt-u2c-v2.x/klipper-usb-to-can/#add-the-mcu-in-klipper-optional","title":"Add the MCU in Klipper (optional)","text":"<p>Finally, you can add the board to your Klipper <code>printer.cfg</code> with its UUID: printer.cfg<pre><code>[mcu U2C]\ncanbus_uuid: &lt;uuid&gt;\n\n# embedded temperature sensor\n[temperature_sensor U2C]\nsensor_type: temperature_mcu\nsensor_mcu: U2C\nmin_temp: 0\nmax_temp: 100\n</code></pre></p> <p>If you don't know the UUID of your U2C, you can read it out with the following command: <pre><code>~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n</code></pre> The output should look like this: </p>"},{"location":"dell-wyse-3040/","title":"Dell Wyse 3040 Thin Client","text":"<p>The Dell Wyse 3040 Thin Client is a compact and good available Mini-PC / Thinclient, valued for its small size and energy efficiency. It has gained attention as a substitute for single-board computers (SBCs) like the Raspberry Pi, also in projects like 3D printers with Klipper/Mainsail as Firmware/GUI.</p> <p>However, the Dell Wyse 3040 is not without any limitation. One of the main drawbacks is the extremely limited internal storage (8GB/16GB eMMC), which can restrict its use in many projects. Fortunately, this issue can be overcome with a simple workaround.</p>"},{"location":"dell-wyse-3040/#specifications","title":"Specifications","text":"<ul> <li>Processor: Intel Atom x5-Z8350 (4 cores, 1.44 GHz)</li> <li>RAM: 2GB DDR3L</li> <li>Storage: 8GB or 16GB eMMC</li> <li>Connectivity: 2x DisplayPort, 3x USB 2.0, 1x USB 3.0, 1x RJ45</li> <li>Networking: 1x Gigabit Ethernet, Wi-Fi (optional)</li> <li>Power: 5V/3A via barrel jack</li> <li>Dimensions: 101.6 x 101.6 x 27.9 mm</li> </ul>"},{"location":"dell-wyse-3040/#images","title":"Images","text":"Dell Wyse 3040 Thin Client - Front Dell Wyse 3040 Thin Client - Back Dell Wyse 3040 Thin Client - Bottom plate open"},{"location":"dell-wyse-3040/install-klipper/","title":"Install Klipper, Moonraker and Mainsail on the Dell Wyse 3040","text":"<p>Setting up Klipper, Moonraker, and Mainsail on the Dell Wyse 3040 Thin Client is a straightforward process, thanks to the use of KIAUH (Klipper Installation And Update Helper). Unlike some other devices, there is no pre-built image available for the Wyse 3040, but KIAUH simplifies the installation and configuration steps significantly.  </p> <p>This guide will walk you through the process of preparing your Wyse 3040, installing the necessary components, and setting up your 3D printer control environment. By following these steps, you can transform this compact thin client into a powerful hub for your 3D printing projects.</p>"},{"location":"dell-wyse-3040/install-klipper/#prerequisites","title":"Prerequisites","text":"<ol> <li>Before you start, ensure you have the following packages installed on your    system:    <pre><code>sudo apt update\nsudo apt upgrade\nsudo apt install git -y\n</code></pre></li> <li> <p>Clone the KIAUH repository to your home directory:    <pre><code>cd ~ &amp;&amp; git clone https://github.com/dw-0/kiauh.git\n</code></pre></p> </li> <li> <p>Open KIAUH by running the following command:    <pre><code>./kiauh/kiauh.sh\n</code></pre></p> </li> <li> <p>Select KIAUH v6 (Currently this version is in the testing phase, but I think    it will be stable enough for our purposes). To use v6 of KIAUH, enter 3 and    press Enter. (This step will be dropped once KIAUH v6 is stable and merged)</p> </li> <li> <p>Now you will see the KIAUH main menu.    </p> </li> </ol>"},{"location":"dell-wyse-3040/install-klipper/#installing-klipper","title":"Installing Klipper","text":"<ol> <li>Install Klipper by selecting option 1 from the KIAUH main menu to open the    installation submenu. Then, select option 1 to install Klipper.</li> <li>First Question is about the Klipper instances, just press Enter to use the    default value (1 instance).</li> <li>Next question is about the Klipper configuration, press Enter to use the    default value (default configuration).</li> <li>Now KIAUH will install Klipper and its dependencies. This process may take    some time, so be patient. (You may enter your password when prompted)</li> <li>Short before the installation is finished, you will be asked if your user    should be added to the <code>dialout</code> group. Press Enter to confirm.</li> <li>After the installation is complete, you will see the Installation submenu    again.</li> </ol>"},{"location":"dell-wyse-3040/install-klipper/#installing-moonraker","title":"Installing Moonraker","text":"<ol> <li>After Klipper is installed, you should be already in the Installation     submenu. If not, open it by selecting option 1 from the KIAUH main menu.</li> <li>Select option 2 to install Moonraker.</li> <li>First question is, if it should create an example configuration. Press Enter    to use the default value (Yes).</li> <li>Now KIAUH will install Moonraker and its dependencies. This process may take    some time, so be patient. (You may enter your password when prompted)</li> <li>After the installation is complete, you will see the Installation submenu    again.</li> </ol>"},{"location":"dell-wyse-3040/install-klipper/#installing-mainsail","title":"Installing Mainsail","text":"<ol> <li>After Moonraker is installed, you should be already in the Installation     submenu. If not, open it by selecting option 1 from the KIAUH main menu.</li> <li>Select option 3 to install Mainsail.</li> <li>First question is, if it should also download the Mainsail-Config. Press    Enter to use the default value (Yes) to download the Mainsail-Config.</li> <li>Now, KIAUH will ask you for the Port, where Mainsail should run. Press Enter    to use the default value (80).</li> <li>Now KIAUH will install Mainsail and its dependencies. This process may take    some time, so be patient. (You may enter your password when prompted)</li> <li>After the installation is complete, you will see the Installation submenu    again. With this short info block above the menu: </li> <li>Open your browser and enter the URL from the info block to access Mainsail.    (In this case, it would be <code>http://192.168.0.37:80</code>)</li> <li>You should see the Mainsail Dashboard, with the error message <code>mcu 'mcu':    Unable to connect</code>. This is expected, as we have not yet configured Klipper.    </li> <li>Congratulations! You have successfully installed Klipper, Moonraker, and    Mainsail on your Dell Wyse 3040 Thin Client. The next step is to configure    Klipper to connect to your 3D printer.</li> </ol>"},{"location":"dell-wyse-3040/install-os/","title":"Install Debian 12 on Dell Wyse 3040 Thin-Client","text":"<p>This guide will walk you through the process of installing Debian 12, ensuring a reliable and flexible operating system for your projects.  </p>"},{"location":"dell-wyse-3040/install-os/#download-debian-12","title":"Download Debian 12","text":"<p>Download the latest Debian 12 image for your Dell Wyse 3040 Thin Client from the official Debian website.</p> <ul> <li>Debian 12.8.0 (Bookworm) Netinst ISO</li> </ul>"},{"location":"dell-wyse-3040/install-os/#create-a-bootable-usb-drive","title":"Create a Bootable USB Drive","text":"<p>Create a bootable USB drive using the downloaded Debian 12 image. You can use tools like Rufus on Windows or <code>dd</code> on Linux/Mac to write the image to the USB drive.</p>"},{"location":"dell-wyse-3040/install-os/#using-dd-on-linuxmac","title":"Using dd on Linux/Mac","text":"<ol> <li>Identify the USB drive using <code>lsblk</code> or <code>diskutil list</code>.</li> <li>Unmount the USB drive with <code>umount /dev/sdX</code> or <code>diskutil unmountDisk    /dev/diskX</code>.</li> <li>Write the Debian 12 image to the USB drive using <code>dd</code>. Replace <code>/dev/sdX</code> or    <code>/dev/diskX</code> with your USB drive identifier.    <pre><code>sudo dd bs=4M if=debian-12.8.0-amd64-netinst.iso of=/dev/sdX; sync\n</code></pre></li> <li>Eject the USB drive with <code>eject /dev/sdX</code> or <code>diskutil eject /dev/diskX</code> on    Mac.</li> </ol>"},{"location":"dell-wyse-3040/install-os/#biosuefi-settings-to-boot-from-usb-drive","title":"BIOS/UEFI Settings to Boot from USB Drive","text":"<p>Before installing Debian 12 on your Dell Wyse 3040 Thin Client, you need to change the BIOS/UEFI settings to boot from the USB drive.</p> <ol> <li>Insert the bootable USB drive into your Dell Wyse 3040 Thin Client.</li> <li>Power on your Dell Wyse 3040 Thin Client.</li> <li>Press the <code>F2</code> key repeatedly during boot to enter the BIOS/UEFI settings.</li> <li>Navigate to the <code>General &gt; Boot Sequence</code> tab using the arrow keys.</li> <li>Enable the USB Storage Boot option. (In my case, it was <code>UEFI: SanDisk Cruzer    Micro 8.02, Partition 1</code>.)</li> <li>Change the boot order to prioritize the USB drive.</li> <li>Click <code>Apply</code> and <code>Exit</code> to save the changes and reboot.</li> </ol> Dell Wyse 3040 BIOS/UEFI Settings"},{"location":"dell-wyse-3040/install-os/#boot-from-usb-drive-and-install-debian-12","title":"Boot from USB Drive and Install Debian 12","text":"<ol> <li>Your Dell Wyse 3040 Thin Client should now boot from the USB drive.</li> <li>Choose the <code>Graphical Install</code> option to start the Debian 12 installation    process with a graphical interface.    </li> <li>Choose your preferred language, location, and keyboard layout.</li> <li>Enter the hostname for your Dell Wyse 3040 Thin Client. (In my case, I used    <code>dell-mainsail</code>.)    </li> <li>Enter the domain name if required. (You can leave it blank if not needed.)    </li> <li>Set the root password for your Dell Wyse 3040 Thin Client.    </li> <li>Create a new user account for your Dell Wyse 3040 Thin Client and type in the    friendly name for the user. (In my case, I created a user named <code>klipper</code>.)    </li> <li>Set the username for the new user account. (Just press <code>Enter</code> to use the    same username as the friendly name.)    </li> <li>Set the password for the new user account.    </li> <li>The next step is the Disk partitioning. This will be a little bit tricky     because of the limited internal storage of the Dell Wyse 3040 Thin Client.     In the first step, you need to choose <code>Guided - use entire disk</code> for a simple     pre partitioning setup.     </li> <li>Select the disk to partition. (In my case, it was     <code>MMC/SD Card #1 (mmcblk0) - 7.8 GB MMC H8G4A?</code>.)     </li> <li>Choose the partitioning scheme. (I selected <code>All files in one partition     (recommended for new users)</code> for simplicity.)     </li> <li>Now, you will see a summary of the disk partitioning. Here we need to make     some changes to optimize the storage usage. Select the <code>ESP</code> partition and     press <code>Enter</code>.     </li> <li>Delete the <code>ESP</code> partition by selecting <code>Delete the partition</code> and then     <code>Delete</code>.     </li> <li>Repeat the same process for all other partitions, until you have only free     space left.     </li> <li>Select the free space and press <code>Enter</code>, then choose <code>Create a new     partition</code> to create a new partition.     </li> <li>Choose the partition size for the first partition. Here we will create a      small partition for the boot files. I choose <code>100M</code> for the boot partition.     </li> <li>In the next step, choose the partition location. Select <code>Beginning</code> to     create the partition at the beginning of the free space.     </li> <li>Now you have to set the first partition. This will be the boot partition.     Use the following settings:<ul> <li>Name: EFI</li> <li>Use as: EFI System Partition</li> <li>Bootable flag: on After setting the partition, press <code>Done setting up the partition</code>. </li> </ul> </li> <li>Now, you will see the new partition created. Select the free space again     and create a new partition for the root filesystem. Choose <code>Create a new     partition</code> and set the partition size. I used the remaining space for the     root partition. Then you should see a summary of the disk partitioning for     the root partition.     </li> <li>At least, select <code>Done setting up the partition</code> to finish the disk     partitioning. If it looks like the following image, you can continue with     the installation with the <code>Finish partitioning and write changes to disk</code>.     </li> <li>In the next step, you will get a warning, that you have not created a swap     partition. You can select <code>No</code> to continue without a swap partition.     </li> <li>Confirm the changes to write the partitioning to the disk.     </li> <li>After the partitioning is completed, the installation of the base system     will start. At some point, you will be asked to configure the package     manager location. Choose your preferred Debian archive mirror.     </li> <li>In the next step, you can choose the Debian archive mirror itself.     </li> <li>The last step to configure the package manager is to set the HTTP proxy     information. You can leave it blank if you don't use a proxy.     </li> <li>Configure the popularity-contest package if you want to participate in the     Debian user experience improvement program. (I chose <code>No</code>.)     </li> <li>Choose the software to install. I deselected all options except for the <code>SSH     server</code> and <code>standard system utilities</code>.     </li> <li>The installation of the base system will continue. After the installation is     complete, you will see this Display.     IMPORTANT: Do not reboot your system yet. You need to install the bootloader     manually.     </li> <li>To install the bootloader, click on <code>Go Back</code>, then select <code>Execute a shell</code>     and click <code>Continue</code>.     </li> <li>Before you see the shell, you will see this dialog. Click <code>Continue</code> to     proceed.     </li> <li>The shell will open. Type the following commands to check the disk name to     mount the EFI partition.     <pre><code>mkdir /mnt/boot\nmount /dev/mmcblk0p1 /mnt/boot\nmkdir /mnt/boot/EFI/BOOT\ntouch /mnt/boot/EFI/BOOT/BOOTX64.EFI\nexit\n</code></pre> </li> <li>With a last click on <code>Continue</code>, the installation will be completed. Now you     the system will reboot.</li> <li>Remove the USB drive from your Dell Wyse 3040 Thin Client.</li> <li>During the boot up, you should hit <code>F2</code> again to enter the BIOS/UEFI     settings and change the boot order to boot from the internal storage.</li> <li>Enter the BIOS/UEFI settings and navigate to the <code>General &gt; Boot Sequence</code>     tab. Enable the Boot Sequence <code>debian</code> and change the boot order to     prioritize it to the top.     </li> <li>Save the changes with <code>Apply</code> and <code>Exit</code> to reboot your Dell Wyse 3040 Thin     Client.</li> <li>Debian 12 should now boot from the internal storage of your Dell Wyse 3040     Thin Client and you should see the console login screen.     </li> <li>Congratulations! You have successfully installed Debian 12 on your Dell Wyse     3040 Thin Client.</li> </ol>"},{"location":"dell-wyse-3040/install-os/#additional-steps","title":"Additional Steps","text":"<p>After installing Debian 12 on your Dell Wyse 3040 Thin Client, you can further customize the system to suit your needs. Here are some additional steps you can take:</p>"},{"location":"dell-wyse-3040/install-os/#install-sudo-and-add-user-to-sudo-group","title":"Install sudo and Add User to sudo Group","text":"<ol> <li>Log in to your Dell Wyse 3040 Thin Client with the root account you created    during the installation.</li> <li>Install the <code>sudo</code> package using the following command:    <pre><code>apt update\napt install sudo\n</code></pre></li> <li>Add your user account to the <code>sudo</code> group to grant administrative privileges:    <code>bash     usermod -aG sudo your_username</code></li> </ol> <p>After completing these steps, you can log in with your user account via SSH and perform administrative tasks using <code>sudo</code>.</p>"},{"location":"dell-wyse-3040/install-os/#reduce-boot-time-with-changing-wait-time-in-grub","title":"Reduce Boot Time with changing wait time in GRUB","text":"<p>Open the <code>/etc/default/grub</code> file with a text editor and change the <code>GRUB_TIMEOUT</code> value to <code>1</code>. This will reduce the boot time significantly.</p> <pre><code>sudo nano /etc/default/grub\n</code></pre> <p>Change the following line: <pre><code>GRUB_TIMEOUT=5\n</code></pre> to <pre><code>GRUB_TIMEOUT=1\n</code></pre></p> <p>Save the file and update the GRUB configuration with the following command: <pre><code>sudo update-grub\n</code></pre></p>"},{"location":"dell-wyse-3040/install-os/#fix-issue-with-reboot-and-shutdown","title":"Fix issue with reboot and shutdown","text":"<p>The Dell Wyse 3040 Thin Client has an issue with HSUART DMA, which can cause problems during reboot and shutdown. To fix this issue, you have to add some lines to <code>/etc/modprobe.d/blacklist.conf</code>. To do this, open the file with a text editor: <pre><code>sudo nano /etc/modprobe.d/blacklist.conf\n</code></pre> and add the following lines: <pre><code>blacklist dw_dmac_core\ninstall dw_dmac /bin/true\ninstall dw_dmac_core /bin/true\n</code></pre> Save the file with <code>Ctrl + S</code> and exit the editor with <code>Ctrl + X</code>. To apply the changes, you have to execute the following command: <pre><code>sudo update-initramfs -u\n</code></pre></p> <p>Now you can shut down and reboot the system without any issues. To test the changes, you can execute the following command: <pre><code>sudo poweroff\n</code></pre> after the system is powered off, you can start it again with a press on the power button.</p>"},{"location":"dell-wyse-3040/install-os/#references","title":"References","text":"<ul> <li>Debian Wiki for Dell Wyse 3040</li> <li>Intel Atom Cherry Trail CPU issue</li> </ul>"},{"location":"mellow-fly-sht-v1/","title":"Mellow FLY-SHT 36/42","text":"<ul> <li>official Repository</li> <li>Schematic</li> </ul>"},{"location":"mellow-fly-sht-v1/#features","title":"Features","text":"<ul> <li>CAN bus connection for stable data transmission over long distances</li> <li>24 volt max input</li> <li>5 amp mosfet for heater control</li> <li>Onboard TMC2209 driver for the extruder</li> <li>Onboard ADXL345 accelerometer to measure resonance for input shaper.</li> <li>Replaceble fan MOS that supports 2 controllable fans.</li> <li>RGB Led control</li> <li>Peripheral interface: USB1, CAN1, FAN2, RGB1, Servo1, Probe1, EndStop3, PT100 4 line1(optional), Thermal1, Heater1</li> </ul>"},{"location":"mellow-fly-sht-v1/#fly-sht-36-v1-size","title":"Fly-SHT 36 v1 Size","text":""},{"location":"mellow-fly-sht-v1/#fly-sht-36-v1-pinout","title":"Fly-SHT 36 v1 Pinout","text":""},{"location":"mellow-fly-sht-v1/#fly-sht-36-v1-termination","title":"Fly-SHT 36 v1 Termination","text":"<p>This board need two jumpers to termination the CAN bus. </p>"},{"location":"mellow-fly-sht-v1/#fly-sht-42-v1-size","title":"Fly-SHT 42 v1 Size","text":""},{"location":"mellow-fly-sht-v1/#fly-sht-42-v1-pinout","title":"Fly-SHT 42 v1 Pinout","text":""},{"location":"mellow-fly-sht-v1/#fly-sht-42-v1-termination","title":"Fly-SHT 42 v1 Termination","text":"<p>This board need two jumpers to termination the CAN bus. </p>"},{"location":"mellow-fly-sht-v1/canboot/","title":"CanBoot bootloader (optional)","text":"<p>Canboot is a bootloader for MCUs to be able to update/flash them via CANBUS. With CanBoot there is no physical intervention (e.g. pressing the boot button) required to flash/update firmware to the MCUs.</p> <p>This guide is tested with the following boards:</p> <ul> <li>Mellow Fly-SHT 42 v1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"mellow-fly-sht-v1/canboot/#download-canboot","title":"Download CanBoot","text":"<p>Clone the CanBoot repository: <pre><code>cd ~\ngit clone https://github.com/Arksine/CanBoot\n</code></pre> To add CanBoot to your moonraker update manager, add this section to your config (optional): moonraker.conf<pre><code>[update_manager canboot]\ntype: git_repo\norigin: https://github.com/Arksine/CanBoot.git\npath: ~/CanBoot\nis_system_service: False\n</code></pre></p>"},{"location":"mellow-fly-sht-v1/canboot/#configure-canboot","title":"Configure CanBoot","text":"<p>Open the config dialog with the following commands: <pre><code>cd ~/CanBoot\nmake menuconfig\n</code></pre> and use following config settings:</p> <ul> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32F072</li> <li>Build CanBoot deployment application: Do not build</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: CAN bus (on PB8/PB9)</li> <li>Application start offset: 8KiB offset</li> <li>CAN bus speed: 500000</li> <li>Support bootloader entry on rapid double click of reset button: check (optional but recommend)</li> <li>Enable Status LED: check</li> <li>Status LED GPIO Pin: !PC13</li> </ul> <p>this should then look like this:</p> <p> </p> CanBoot config for Mellow FLY-SHT devices <p>use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>These lines just clear the cache and compile the CanBoot bootloader: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"mellow-fly-sht-v1/canboot/#flash-canboot","title":"Flash CanBoot","text":"<p>First, you have to put the board into DFU mode. To do this, plug in a jumper to the following pins and then plug in the usb cable: </p> <p>With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode. If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash CanBoot with the following command: <pre><code>dfu-util -a 0 -D ~/CanBoot/out/canboot.bin -s 0x08000000:mass-erase:force\n</code></pre>  Now remove the jumper and unplug &amp; plug-in the USB cable again. If the board is in CanBoot mode, the LED should blink.</p>"},{"location":"mellow-fly-sht-v1/klipper/","title":"Klipper Firmware for Mellow Fly-SHT 36/42 v1","text":"<p>The BigTreeTech EBB series is a toolhead board series that can communicate via CAN. This guide explains which settings you need, to flash your EBB boards with Klipper.</p> <p>This guide is tested with the following boards:</p> <ul> <li>Mellow Fly-SHT 42 v1</li> </ul> <p>This guide was verified on a Pi running MainsailOS</p>"},{"location":"mellow-fly-sht-v1/klipper/#configure-klipper-firmware","title":"Configure Klipper firmware","text":"<p>Open the config interface of the Klipper firmware with following commands: <pre><code>cd ~/klipper\nmake menuconfig\n</code></pre> and set the following settings:</p> <ul> <li>Enable extra low-level configuration options: check</li> <li>Micro-controller Architecture: STMicroelectronics STM32</li> <li>Processor model: STM32F072</li> <li>Bootloader offset: No bootloader (without CanBoot)</li> <li>Bootloader offset: 8KiB bootloader (with CanBoot)</li> <li>Clock Reference: 8 MHz crystal</li> <li>Communication interface: CAN bus (on PB8/PB9)</li> <li>CAN bus speed: 500000</li> </ul> <p> use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p>"},{"location":"mellow-fly-sht-v1/klipper/#flash-klipper","title":"Flash Klipper","text":"<p>There are two ways to flash the Klipper firmware to the EBB.</p> <ul> <li>Flash the firmware via USB </li> <li>Flash the firmware via CAN (recommended) (only with CanBoot)</li> </ul>"},{"location":"mellow-fly-sht-v1/klipper/#flash-klipper-via-usb","title":"Flash Klipper via USB","text":"<p>This is the classic way to flash the firmware to the Fly-SHT.</p> <p>First, you have to put the board into DFU mode. To do this, plug in a jumper to the following pins and then plug in the usb cable: </p> <p>With the command <code>dfu-util -l</code>, you can check if the board is in DFU mode. If dfu-util can discover a board in DFU mode it should then look like this:  If this is not the case, repeat the boot/restart process and test it again.</p> <p>If your board is in DFU mode, you can flash Klipper with the following command: <pre><code>dfu-util -a 0 -D ~/klipper/out/klipper.bin -s 0x08000000:mass-erase:force\n</code></pre>  Now remove the jumper and unplug &amp; plug-in the USB cable again.</p>"},{"location":"mellow-fly-sht-v1/klipper/#flash-klipper-via-can","title":"Flash Klipper via CAN","text":"<p>This is the recommended way to flash the firmware, when you use CanBoot on your board.</p> <p>Find the UUID of your board: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -i can0 -q\n</code></pre> The output should look like this: </p> <p>With the UUID you have just read, you can now flash the board with: <pre><code>python3 ~/CanBoot/scripts/flash_can.py -f ~/klipper/out/klipper.bin -i can0 -u &lt;uuid&gt;\n</code></pre> </p>"},{"location":"mellow-fly-sht-v1/klipper/#add-the-mcu-in-klipper","title":"Add the MCU in Klipper","text":"<p>Finally, you can add the board to your Klipper <code>printer.cfg</code> with its UUID: printer.cfg<pre><code>[mcu SHT]\ncanbus_uuid: &lt;uuid&gt;\n\n# embedded temperature sensor\n[temperature_sensor SHT]\nsensor_type: temperature_mcu\nsensor_mcu: SHT\nmin_temp: 0\nmax_temp: 100\n</code></pre></p> <p>If you don't know the UUID of your SHT, you can read it out with the following command: <pre><code>~/klippy-env/bin/python ~/klipper/scripts/canbus_query.py can0\n</code></pre> The output should look like this: </p>"},{"location":"nginx-basic-auth/","title":"Access Restriction with Basic Authentication for Mainsail","text":"<p>In this tutorial, I'll show you how to set up simple access restriction for Mainsail using NGINX. This method is just a simple access restriction and is not a security feature to protect Mainsail!</p>"},{"location":"nginx-basic-auth/#prerequisites","title":"Prerequisites","text":"<ul> <li>MainsailOS installed on your Raspberry Pi or similar setup (e.g., KIAUH)</li> <li>SSH access to your Raspberry Pi</li> <li>Basic knowledge of Linux and the command line</li> </ul>"},{"location":"nginx-basic-auth/#step-1-configure-basic-authentication","title":"Step 1: Configure Basic Authentication","text":""},{"location":"nginx-basic-auth/#install-apache2-utils","title":"Install Apache2-utils","text":"<p>First, install the <code>apache2-utils</code> package, which provides the <code>htpasswd</code> tool to create and manage user files for basic authentication.</p> <pre><code>sudo apt update\nsudo apt install apache2-utils\n</code></pre>"},{"location":"nginx-basic-auth/#create-user-file","title":"Create User File","text":"<p>Next, create a user file with the <code>htpasswd</code> tool. Replace <code>username</code> with your desired username.</p> <pre><code>sudo htpasswd -c /etc/nginx/.htpasswd username\n</code></pre> <p>You will be prompted to enter a password for the user. After entering the password, the user file will be created.</p>"},{"location":"nginx-basic-auth/#modify-file-permissions","title":"Modify File Permissions","text":"<p>Change the permissions of the <code>.htpasswd</code> file to prevent unauthorized access.</p> <pre><code>sudo chmod 640 /etc/nginx/.htpasswd\nsudo chown root:www-data /etc/nginx/.htpasswd\n</code></pre>"},{"location":"nginx-basic-auth/#step-2-update-nginx-configuration","title":"Step 2: Update NGINX Configuration","text":""},{"location":"nginx-basic-auth/#edit-nginx-configuration-file","title":"Edit NGINX Configuration File","text":"<p>Open the NGINX configuration file in a text editor.</p> <pre><code>sudo nano /etc/nginx/sites-available/mainsail\n</code></pre> <p>Add the following lines to the <code>server</code> block.</p> <pre><code>auth_basic \"Restricted Access\";\nauth_basic_user_file /etc/nginx/.htpasswd;\n</code></pre> <p>So it looks like this:</p> <pre><code>server {\n    listen 80 default_server;\n    # uncomment the next line to activate IPv6\n    # listen [::]:80 default_server;\n\n    auth_basic \"Restricted Access\";\n    auth_basic_user_file /etc/nginx/.htpasswd;\n\n    access_log /var/log/nginx/mainsail-access.log;\n    error_log /var/log/nginx/mainsail-error.log;\n\n    # some more lines...\n</code></pre> <p>Then save the file and exit the text editor. To save the file in Nano, press <code>Ctrl + O</code>, then <code>Enter</code>, and to exit, press <code>Ctrl + X</code>.</p>"},{"location":"nginx-basic-auth/#step-3-check-and-reload-nginx","title":"Step 3: Check and Reload NGINX","text":"<p>Check the NGINX configuration for syntax errors.</p> <pre><code>sudo nginx -t\n</code></pre> <p>If the configuration is correct, reload NGINX to apply the changes.</p> <pre><code>sudo systemctl reload nginx\n</code></pre>"},{"location":"nginx-basic-auth/#step-4-test-access","title":"Step 4: Test Access","text":"<p>Open your browser and navigate to your Mainsail instance. You should now be prompted to enter the username and password you created earlier.</p>"},{"location":"nginx-basic-auth/#important-notes","title":"Important Notes","text":"<ul> <li>This method is a simple access restriction and is not a security feature to   protect Mainsail.</li> <li>Make sure to keep your username and password secure.</li> <li>If you forget your password, you can recreate the user file with a new   password.</li> <li>To remove the access restriction, remove the <code>auth_basic</code> lines from the NGINX   configuration file and reload NGINX.</li> </ul>"},{"location":"pa-calibration-la-test/","title":"PA-Calibration with LA-Test","text":"<p>This is a fast calibration test for Pressure Advanced. The idea was from FHeilmann.</p> <p></p>"},{"location":"pa-calibration-la-test/#requirements","title":"Requirements","text":"<p>At first, we have to add a gcode-macro to convert the M900 LA gcode to set the Pressure Advance value. Please add the following lines in your <code>printer.cfg</code>. printer.cfg<pre><code>[gcode_macro M900]\ndescription: Set Pressure Advance\ngcode: SET_PRESSURE_ADVANCE ADVANCE={params.K|default(0)}\n</code></pre></p>"},{"location":"pa-calibration-la-test/#generate-g-code","title":"Generate G-code","text":"<p>Now we use the Marlin k-factor tool to generate the G-code. Here are my parameters I used to generate the pattern in the picture above.</p> <p> </p> Change Hotend, Bed-Temperature and Retraction-Distance <p> </p> Resize the bed to your size <p> </p> Change the Retract Speed to your Retract-Speed <p> </p>      Ending Value max is 1 (Bowden). If you use a Direct-Drive printer, you can set the \"Ending Value for K\" to 0.25 and     \"K-faktor Stepping\" to 0.01. If you like to print the Numbers per Line, check-in the \"Line Numbering\" (the numbers     are horrible to remove from your buildplate).    <p> </p> Change the \"Extrusion Multiplier\" for you filament <p>Fill in a Filename in the field and click on \"Generate G-code\". Modify the Start-Gcode on the right side and click on \"Download as file\".</p>"},{"location":"pa-calibration-la-test/#print-the-g-code","title":"Print the G-code","text":"<p>Now print the pattern and look at which line is most constant. Count the lines from below and multiply with the \"K-factor Stepping\" value. This is your perfect Pressure Advance value.</p> <p>Happy printing!</p>"},{"location":"snakeoil-certificates/","title":"Snakeoil Certificates","text":"<p>The snakeoil certificates are used by default in the <code>ssl-cert</code> package on Debian and Ubuntu. They are used for testing or private purposes.</p>"},{"location":"snakeoil-certificates/#generate-new-certificate","title":"Generate new certificate","text":"<pre><code># install dependencies\nsudo apt-get install ssl-cert\n# add pi user to ssl-cert group\nsudo adduser pi ssl-cert\n# generate new certificates\nmake-ssl-cert generate-default-snakeoil --force-overwrite\n</code></pre> <p>This will generate the following files: <pre><code># certificate\n/etc/ssl/certs/ssl-cert-snakeoil.pem\n# private key\n/etc/ssl/private/ssl-cert-snakeoil.key\n</code></pre></p>"},{"location":"snakeoil-certificates/#use-snakeoil-certificate-with-moonraker","title":"Use snakeoil certificate with Moonraker","text":"<p>To use the snakeoil certificate with Moonraker, you have to create symbol links to the certificate and the private key: <pre><code>ln -s /etc/ssl/certs/ssl-cert-snakeoil.pem /home/pi/printer_data/certs/moonraker.cert\nln -s /etc/ssl/private/ssl-cert-snakeoil.key /home/pi/printer_data/certs/moonraker.key\n</code></pre> after that, you have to restart Moonraker.</p>"},{"location":"snakeoil-certificates/#use-snakeoil-certificate-with-mainsailnginx","title":"Use snakeoil certificate with Mainsail/Nginx","text":"<p>Open your nginx config with <code>sudo nano /etc/nginx/sites-available/mainsail</code> and add the following lines: <pre><code>listen 443 ssl default_server;\nssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;\nssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;\n</code></pre> To restart nginx, use <code>sudo systemctl restart nginx</code>.</p> <p>Now you can open Mainsail with <code>https://&lt;your-ip&gt;</code>. You only have to \"allow\" the certificate in your browser because it is self-signed and not signed by a trusted CA.</p>"},{"location":"ssd1306-display/","title":"Klipper with SSD1306 Display","text":"<p>The SSD1306 is a small display that can be used to display information from Klipper. The display is connected via I2C to the SBC or the MCU. The display has a resolution of 128x64 pixels and is available in different colors.</p> <p></p> <p>Because the display can be used with different SBCs or MCUs/boards, i have worked out several instructions:</p> <ul> <li>Raspberry Pi with Host MCU</li> </ul>"},{"location":"ssd1306-display/rpi-host-mcu/","title":"SSD1306 connected to Raspberry Pi with Host MCU","text":"<p>This guide describes how to connect a SSD1306 display to a Raspberry Pi and install a Klipper Host MCU to use the Display.</p>"},{"location":"ssd1306-display/rpi-host-mcu/#install-klipper-host-mcu","title":"Install Klipper Host MCU","text":"<p>At first, you have to install the service for the Klipper Host MCU. To do this, you have to execute the following commands:</p> <pre><code>cd ~/klipper/\nsudo cp ./scripts/klipper-mcu.service /etc/systemd/system/\nsudo systemctl enable klipper-mcu.service\n</code></pre> <p>After that, you have to \"flash\" the Klipper Host MCU to the Raspberry Pi. To open the Klipper Firmware configuration:</p> <pre><code>cd ~/klipper/\nmake menuconfig\n</code></pre> <p>In the menu, you have to select the following options:</p> <ul> <li>Enable extra low-level configuration options: uncheck</li> <li>Microcontroller Architecture: Linux process</li> </ul> <p>The result should look like this:  use <code>q</code> for exit and <code>y</code> for save these settings.</p> <p>Now clear the cache and compile the Klipper firmware: <pre><code>make clean\nmake\n</code></pre></p> <p>To flash the Klipper Host MCU to the Raspberry Pi, you have to execute the following commands:</p> <pre><code># stop klipper service\nsudo systemctl stop klipper\n\n# flash klipper-mcu\nmake flash\n\n# start klipper-mcu service\nsudo systemctl start klipper-mcu\n\n# start klipper service\nsudo systemctl start klipper\n</code></pre> <p>Now, Klipper Host MCU is installed and running on your Raspberry Pi. To add it to your Klipper configuration, you have to add the following lines to your <code>printer.cfg</code>:</p> <pre><code>[mcu host]\nserial: /tmp/klipper_host_mcu\n</code></pre> <p>and restart Klipper.</p> <p>Permission denied error in klippy.log</p> <p>If you get the error \"Permission denied\" in the klippy.log, you have to add your user to the dialout group:</p> <pre><code>sudo usermod -a -G tty pi\n</code></pre>"},{"location":"ssd1306-display/rpi-host-mcu/#enable-i2c-on-raspberry-pi","title":"Enable I2C on Raspberry Pi","text":"<p>To enable the I2C interface on the Raspberry Pi, you have to execute the following commands:</p> <pre><code>echo \"dtparam=i2c_arm=on\" | sudo tee -a /boot/config.txt\necho \"i2c-dev\" | sudo tee -a /etc/modules\n</code></pre> <p>To activate the changes, you have to reboot the Raspberry Pi with <code>sudo reboot</code>.</p> <p>After the reboot, you can check if the I2C interface is enabled with the following command:</p> <pre><code>ls /dev/i2c-*\n</code></pre> <p>This should look like:</p> <p></p>"},{"location":"ssd1306-display/rpi-host-mcu/#connect-ssd1306-to-rpi","title":"Connect SSD1306 to RPi","text":"<p>Connect the SSD1306 display to the Raspberry Pi with the following pins:</p> <ul> <li>VCC -&gt; 3.3V (Pin 1)</li> <li>GND -&gt; GND (Pin 6)</li> <li>SCL -&gt; SCL (Pin 5)</li> <li>SDA -&gt; SDA (Pin 3)</li> </ul> <p>To check if the connection is working, you have to install the <code>i2cdetect</code> tool with:</p> <pre><code>sudo apt install i2c-tools\n</code></pre> <p>and then you can use the following command to test the connection:</p> <pre><code>sudo i2cdetect -y 1\n</code></pre> <p>This should look like:  Important is the <code>3c</code> in the output. This is the address of the SSD1306 display.</p>"},{"location":"ssd1306-display/rpi-host-mcu/#add-ssd1306-to-klipper-configuration","title":"Add SSD1306 to Klipper configuration","text":"<p>To add the SSD1306 display to your Klipper configuration, you have to add the following lines to your <code>printer.cfg</code>:</p> <pre><code>[display]\nlcd_type: ssd1306\ni2c_mcu: host\ni2c_bus: i2c.1\n</code></pre> <p>and restart Klipper.</p> <p>The result should look like this: </p> <p>(Yes, this looks not very nice, but it works. If you have a better screen layout for Klipper, please let me know.)</p>"}]}